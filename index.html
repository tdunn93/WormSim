<!DOCTYPE html>
<html lang="en">
  <head> 
    <meta charset="utf-8">
      <title>WormSim: Worm propogation simulator</title>
<script type="text/javascript" src="d3/d3.js"></script>
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script src="//code.jquery.com/ui/1.11.3/jquery-ui.js"></script>
<style type="text/css">

.ui-widget {
    font-family: Verdana, Arial, sans-serif;
    font-size: .8em;
}
.ui-widget-content {
    background: #F9F9F9;
    border: 1px solid #90d93f;
    color: #222222;
}
.ui-dialog {
    left: 0;
    outline: 0 none;
    padding: 0 !important;
    position: absolute;
    top: 0;
}
#success {
    padding: 0;
    margin: 0;
}
.ui-dialog .ui-dialog-content {
    background: none repeat scroll 0 0 transparent;
    border: 0 none;
    overflow: auto;
    position: relative;
    padding: 0 !important;
}
.ui-widget-header {
    background: #b0de78;
    border: 0;
    color: #fff;
    font-weight: normal;
}
.ui-dialog-titlebar-close {
    display:none;
}
</style>
<body>
    <h1 style="font-size:200%"> <center> WormSim</center> </h1> 
    <div id="Info" title="Information">
        <p>WormSim - A computer worm propogation simulator, enables combinations of different known worms, attack & defense methods and network topologies to be configured in order to simulate how worms may behave in different environments</p>
        <p>The basic three levels represent ficticious university mesh networks of varying size, the custom level allows for arbitary configuration of different
           topologies and attack types to be used.<p>
    </div>
    <button class="Info">Info</button>
    <div id="Legend" title="Legend">
        <p><font color="green">Represents an uninfected node.</font> 
        </p>
        <p><font color="red">Represents an incapacitated node.</font> 
        </p>
        <p><font color="orange">Represents a node infected with
           W32.ILOVEYOU</font>. ILOVEYOU orginated from the Philippines and attacked tens of millions of computers by spreading an  email message with the subject line "ILOVEYOU" and the attachment "LOVE-LETTER-FOR-YOU.txt.vbs". In this case the visual basic extension was hidden, the worm used social engineering to lead users to think it was an ordinary text file, upon opening the script it did damage to local files and propgated itself further by email harvesting.
        </p>
        <p><font color="purple">Represents a node infected with
         W32.BLASTER</font> Blaster exploited a vulnerability on windows server 2003, it then opened a UDP port and began to upload its viral payload before looking for new machines to infect.</p>
        <p><font color="brown">Represents a node infected with
         W32.BORM</font> Borm was among one of the first worms to attack a backdoor compromised system, it made use of a remote administration facility called back orifice to infect targets</p>
        <p><b>Honey pots </b>are strategic defence mechanisms which lure in worms by redirecting their target locators from compromised nodes, minimising network damage. </p>
        <p><b> Intrusion detection systems</b> monitor network traffic for suspicious activity, if a suspicious packet is found it is dropped.</p>
    </div>
    <button class="Legend">Legend</button>
    <br>
    <br>
    <button id="buttonOne" onclick="levelOne()">Level one</button>
    <div id="divLevelOne"></div>
    <br>
    <button onclick="levelTwo()">Level two</button>
    <div id="divLevelTwo"></div>
    <br>
    <button onclick="levelThree()">Level three</button>
    <div id="divLevelThree"></div>
    <br>
    <button onclick="levelCustom()">Custom</button>
    <div id="divLevelCustom"></div>
    <br>
    <div id="commentary"></div>
</body>
      <script type="text/javascript">
			//Width and height
//vars to hold dropdown menu data
var networkSelectMenu;
var socialEngSelectMenu;
var intrustionDetectMenu;
var softwareMenu;
var honeypotSelectMenu;
var wormSelectMenu;
var wormBtn;
var nodeTextBox;
var topologySelectMenu;
var infectionMethodMenu;
var attackSelectMenu;
var botnetMinMenu;


//dfs counter and max tracker
var counter = 0;
var max = 0;

var diameter;
var smurf = false;
var star = false;
var selected = false;
var converged = false;
var stopSimulation = false;
var stageEnded = false; //to keep track of whether to spawn next worm
//grouping for nodes
var gnodes;

//fd layout 
var force;

//var for svg elements
var svg;

var w = 850;
var h = 650;

var spawn; //initial outbreak node
var xyCoords = []; //worm xy coords
var infections = [];
var newMarkedInfections = [];
var infected = []; //infect node indexes
var honeypots = []; //honeypot nodes
var visited = [];

var smurfData = {};

var numInfections = 0;
var botnetMin; //minimum number of nots req for storm botnet to incapacitate node

var node_params = {
    social_eng: false,
    intrusion_detect: false,
    honeypot: false 
};

var bool_params = [" true", " false"];
var attacks = ["Worm", "DDoS.Smurf", "Botnet.Storm"];

var topologies = ["Line", "Star", "Complete", "Ring", "Mesh", "Hybrid"];

var worms = [
    { name: "W32.BORM", techniques: ["BUFF_OVERFLOW"]
    , packet_types: ["TCP"], ports_used: [135] },
    { name: "W32.BLASTER", techniques: ["BUFF_OVERFLOW"]
     , packet_types: ["TCP", "UDP"], ports_used: [135, 139, 4444] },
    { name: "W32.ILOVEYOU", techniques: ["SOCIAL_ENG"]
     , packet_types: ["TCP", "UDP"], ports_used: [22] }
    ];

//datasets for levels
var dataset1 = {
  nodes: [
      { name: "Manchester University", system_type: "W32", social_eng: " false"
               , intrusion_detect: " false", honeypot: " false", software_uptodate: " false"
       , status: "active", infected_with: "none", adjacent_to: [1, 2]},
      { name: "Leeds University", system_type: "W32", social_eng: " false"
             , intrusion_detect: " false", honeypot: " false", software_uptodate: " false"
       , status: "active", infected_with: "none", adjacent_to: [2, 0]},
      { name: "Liverpool Univeristy", system_type: "W32", social_eng: " false"
            , intrusion_detect: " false", honeypot: " false", software_uptodate: " false"
       , status: "active", infected_with: "none", adjacent_to: [1, 0]},

    ],
  edges: [
    { source: 0, target: 1 },
    { source: 0, target: 2 },
	{ source: 1, target: 2 },
	{ source: 1, target: 0 },
	{ source: 2, target: 1 },
   ]
 };

var dataset2 = {
  nodes: [
    { name: "Manchester University", system_type: "W32", social_eng: " false"
            , intrusion_detect: " false", honeypot: " false", software_uptodate: " false"
            , status: "active", infected_with: "none", adjacent_to: [1, 6, 3]},
    { name: "Leeds University", system_type: "W32", social_eng: " false"
            , intrusion_detect: " false", honeypot: " false", software_uptodate: " false"
            , status: "active", infected_with: "none", adjacent_to: [2, 0]},
    { name: "Liverpool Univeristy", system_type: "W32", social_eng: " false"
            , intrusion_detect: " false", honeypot: " false", software_uptodate: " false"
            , status: "active", infected_with: "none", adjacent_to: [1, 6]},
    { name: "University of Bristol", system_type: "W32", social_eng: " false"
            , intrusion_detect: " false", honeypot: " false", software_uptodate: " false"
            , status: "active", infected_with: "none", adjacent_to: [0, 6]},
    { name: "Imperial College London", system_type: "W32", social_eng: " false"
            , intrusion_detect: " false", honeypot: " false", software_uptodate: " false"
            , status: "active", infected_with: "none", adjacent_to: [5, 6]},
    { name: "University of Edinburgh", system_type: "W32", social_eng: " false"
            , intrusion_detect: " false", honeypot: " false", software_uptodate: " false"
            , status: "active", infected_with: "none", adjacent_to: [4]},
    { name: "Univeristy College London", system_type: "W32"
            , social_eng: " false"
            , intrusion_detect: " false", honeypot: " false", software_uptodate: " false"
            , status: "active" , infected_with: "none"
            , adjacent_to: [0, 2, 3, 4]},
    ],
  edges: [
    { source: 0, target: 1 },
	{ source: 1, target: 2 },
	{ source: 1, target: 0 },
	{ source: 2, target: 1 },
	{ source: 3, target: 6 },
	{ source: 3, target: 0 },
	{ source: 4, target: 6 },
	{ source: 5, target: 4 },
	{ source: 6, target: 2 },
	{ source: 6, target: 0 },

   ]
 };

var dataset3 = {
  nodes: [
    { name: "Manchester University", system_type: "W32", social_eng: " false"
     , intrusion_detect: " false", honeypot: " false", software_uptodate: " false", status: "active"
             , infected_with: "none", adjacent_to: [1, 3, 6, 11, 14]},
    { name: "Leeds University", system_type: "W32", social_eng: " false"
             , intrusion_detect: " false", honeypot: " false", software_uptodate: " false"
     , status: "active" , infected_with: "none", adjacent_to: [0, 2, 8]},
    { name: "Liverpool Univeristy", system_type: "W32", social_eng: " false"
             , intrusion_detect: " false", honeypot: " false", software_uptodate: " false"
            , status: "active" , infected_with: "none"
            , adjacent_to: [1, 6, 11, 12, 14]},
    { name: "University of Bristol", system_type: "W32", social_eng: " false" 
             , intrusion_detect: " false", honeypot: " false", software_uptodate: " false"
             , status: "active" , infected_with: "none", adjacent_to: [0, 6]},
    { name: "Imperial College London", system_type: "W32", social_eng: " false"
             , intrusion_detect: " false", honeypot: " false", software_uptodate: " false"
             , infected_with: "none", adjacent_to: [5, 6, 7]},
    { name: "University of Edinburgh", system_type: "W32", social_eng: " false"
             , intrusion_detect: " false", honeypot: " false", software_uptodate: " false"
             , status: "active" , infected_with: "none", adjacent_to: [4, 10]},
    { name: "Univeristy College London", system_type: "W32"
             , social_eng: " false"
             , intrusion_detect: " false", honeypot: " false", software_uptodate: " false"
             , status: "active" , infected_with: "none"
             , adjacent_to: [3, 4, 7, 10]},
    { name: "Univeristy of Nottingham", system_type: "W32"
             , social_eng: " false"
             , intrusion_detect: " false", honeypot: " false", software_uptodate: " false"
             , status: "active", infected_with: "none"
             , adjacent_to: [4, 6, 12, 13]},
    { name: "University of Sheffield", system_type: "W32", social_eng: " false" 
             , intrusion_detect: " false", honeypot: " false", software_uptodate: " false"
             , status: "active", infected_with: "none"
             , adjacent_to: [1, 9, 10]},
    { name: "University of York", system_type: "W32", social_eng: " false" 
             , intrusion_detect: " false", honeypot: " false", software_uptodate: " false"
             , status: "active" , infected_with: "none", adjacent_to: [8, 10]},
    { name: "London School of Economics", system_type: "W32"
             , social_eng: " false" 
             , intrusion_detect: " false", honeypot: " false", software_uptodate: " false"
             , status: "active" , infected_with: "none"
             , adjacent_to: [5, 6, 8, 9]},
    { name: "Oxford University", system_type: "W32", social_eng: " false"
             , intrusion_detect: " false", honeypot: " false", software_uptodate: " false"
             , status: "active", infected_with: "none", adjacent_to: [0, 2]},
    { name: "Cambridge University", system_type: "W32", social_eng: " false"
             , intrusion_detect: " false", honeypot: " false", software_uptodate: " false"
             , status: "active" , infected_with: "none", adjacent_to: [2, 7]},
    { name: "Trinity College Dublin", system_type: "W32", social_eng: " false"
             , intrusion_detect: " false", honeypot: " false", software_uptodate: " false"
             , status: "active" , infected_with: "none", adjacent_to: [7]},
    { name: "University of Glasgow", system_type: "W32", social_eng: " false" 
             , intrusion_detect: " false", honeypot: " false", software_uptodate: " false"
             , status: "active" , infected_with: "none", adjacent_to: [0, 2]},
    ],
  edges: [
    { source: 0, target: 1 },
	{ source: 1, target: 2 },
	{ source: 1, target: 0 },
	{ source: 2, target: 1 },
	{ source: 3, target: 6 },
	{ source: 3, target: 0 },
	{ source: 4, target: 6 },
	{ source: 5, target: 4 },
	{ source: 6, target: 2 },
	{ source: 6, target: 0 },
	{ source: 7, target: 4 },
	{ source: 7, target: 6 },
	{ source: 8, target: 10 },
	{ source: 8, target: 1 },
	{ source: 9, target: 8 },
	{ source: 10, target: 6 },
	{ source: 10, target: 5 },
	{ source: 10, target: 9 },
	{ source: 11, target: 2 },
	{ source: 11, target: 0 },
	{ source: 12, target: 7 },
	{ source: 12, target: 2 },
	{ source: 13, target: 7 },
	{ source: 14, target: 2 },
	{ source: 14, target: 0 },
   ]
 };

 //Initialize a default force layout, using the nodes and edges in dataset
var colors = d3.scale.category10();

//need to make copys of datasets for complete refresh
var levelOne = function()
{
  diameter = 2;
  $("#divLevelTwo").empty();
  $("#divLevelThree").empty();
  $("#divLevelCustom").empty();
  d3.selectAll("svg").remove(); //remove all the svg elements for new graph
  generate_dropdown(dataset1, "divLevelOne", diameter);
  generate_graph(dataset1);
  $("#commentary").fadeOut(function() {
    $(this).text("Level one generated").fadeIn(2000);
    $(this).text("Level one generated").fadeOut(2000);
  });
  //$("#commentary").empty();
}

var levelTwo = function()
{
  diameter = 5;
  $("#divLevelOne").empty();
  $("#divLevelThree").empty();
  $("#divLevelCustom").empty();
  d3.selectAll("svg").remove();
  generate_dropdown(dataset2, "divLevelTwo");
  generate_graph(dataset2);
  $("#commentary").fadeOut(function() {
    $(this).text("Level two generated").fadeIn(2000);
    $(this).text("Level two generated").fadeOut(2000);
  });
  //$("#commentary").empty();
} 

var levelThree = function()
{
  $("#divLevelOne").empty();
  $("#divLevelTwo").empty();
  $("#divLevelCustom").empty();
  d3.selectAll("svg").remove();
  generate_dropdown(dataset3, "divLevelThree");
  generate_graph(dataset3);
  $("#commentary").fadeOut(function() {
    $(this).text("Level three generated").fadeIn(2000);
    $(this).text("Level three generated").fadeOut(2000);
  });
}

var levelCustom = function()
{
  $("#divLevelOne").empty();
  $("#divLevelTwo").empty();
  $("#divLevelThree").empty();
  d3.selectAll("svg").remove();
  generate_custom();
}

var info = function()
{
  createDialog("hello", "m8")
}

function createDialog(title, text) {
    $(document).ready(function () {
    return $("<div class='dialog' title='" + title + "'><p>" + text + "</p></div>")
    .dialog({
        resizable: false,
        height:140,
        modal: true,
        dialogClass: 'dialogStyle.ui-dialog',
        buttons: {
            "Confirm": function() {
                $( this ).dialog( "close" );
            },
            Cancel: function() {
                $( this ).dialog( "close" );
            }
        }
    });
    });
}

//generate_graph(dataset3); 
//Graph generator
function generate_graph(dataset)
{
  //var copy = duplicate(dataset);
    
  force = d3.layout.force()
    .nodes(dataset.nodes)
    .links(dataset.edges)
    .size([w, h])
    .linkDistance([100])
    .charge([-500])
    .start()
    .on("end", function() {
      converged = true;
  });
    

	              
  //Create an SVG element
     svg = d3.select("body")
    .append("svg")
    .attr("width", w)
    .attr("height", h);
			
//Create edges as lines
  var edges = svg.selectAll("line")
    .data(dataset.edges)
    .enter()
    .append("line")
    .style("stroke", "#ccc")
    .style("stroke-width", 1);
 
//Create a group of elements for the nodes
     gnodes = svg.selectAll('g.gnode')
    .data(dataset.nodes)
    .enter()
    .append('g')
    .classed('gnode', true)

    
//Add a circle to the node   
  var nodes = gnodes.append("circle")
    /*.attr("xlink:href", "/Desktop/project-folder/comp.ico")
    .attr("x", -8)
    .attr("y", -8)
    .attr("width", 30)
    .attr("height", 30)
  */
  .attr("class", "node")
  .attr("r", 10)
  .style("fill", function(d) {
      console.log(d.infected_with.slice(d.length - 13, d.length));
      if(d.name != "Central Hub") {
          console.log(d.status);
        if(d.status == "incapacitated")
            return "red";
          else{
        if(d.infected_with == "W32.BORM") 
            return "brown";
        else if(d.infected_with == "W32.BLASTER")
            return "purple";
        else if(d.infected_with == "W32.ILOVEYOU")
            return "orange";
        else if(d.infected_with == "W32.SLAMMER")
            return "blue";
        else if(d.infected_with == "W32.STORM")
            return "violet";
        else if(d.infected_with.slice(d.length - 13, d.length) 
                == "Incapacitated")
            return red;
       /* else if(d.infected_with == "W32.SLAMMER - Node: Incapacitated")
            return "red";*/
        else {
          return "green";
        }
          }
      }
      else
          return "green";
   })
    .on("mouseover", function(d) {
      if(d.name != "Central Hub") {
        d3.select(labels[0][d.index])
        .style("visibility", "visible");
        d3.select(labels[0][d.index].nextSibling)
        .style("visibility", "visible");
        d3.select(labels[0][d.index].nextSibling.nextSibling)
        .style("visibility", "visible");
        d3.select(labels[0][d.index].nextSibling.nextSibling.nextSibling)
        .style("visibility", "visible");
        d3.select(labels[0][d.index].nextSibling.nextSibling.nextSibling.nextSibling)
        .style("visibility", "visible");
        d3.select(labels[0][d.index].nextSibling.nextSibling.nextSibling.nextSibling.nextSibling)
        .style("visibility", "visible");
      }
        else {
         d3.select(labels[0][d.index])
        .style("visibility", "visible");
        }     
    })
    .on("mouseout", function(d) {
     d3.select(labels[0][d.index])
       .style("visibility", "hidden");
      d3.select(labels[0][d.index].nextSibling)
      .style("visibility", "hidden");
      d3.select(labels[0][d.index].nextSibling.nextSibling)
      .style("visibility", "hidden");
      d3.select(labels[0][d.index].nextSibling.nextSibling.nextSibling)
      .style("visibility", "hidden");
      d3.select(labels[0][d.index].nextSibling.nextSibling.nextSibling.nextSibling)
        .style("visibility", "hidden");
      d3.select(labels[0][d.index].nextSibling.nextSibling.nextSibling.nextSibling.nextSibling)
        .style("visibility", "hidden");
    })
    //.on("click", function(d) {
    
    .call(force.drag);

//Labels for the group
  
  var labels = gnodes.append("text")
    .text(function(d) { 
        return ("Network: " + d.name ); 
    })
    .attr("class","nodetext")
    .attr("dx", 0)
    .attr("dy", ".35em")
    .style("font-size","5px")
    .attr("text-anchor", "middle")
    .attr("transform","translate(0, 24)")
    //.style("fill", "white")
    .transition()
    .duration(300)
    .style("font-size","12px")
 // .attr("font-family", "sans-serif")
 // .attr("font-size", "11px")
    .style("visibility", "hidden"); //hide under hover over the node 
    
    gnodes.append("text")
    .text(function(d) { 
        return ("Social Engineering Training: " + d.social_eng); 
    })
    .attr("class","nodetext")
    .attr("dx", 0)
    .attr("dy", ".35em")
    .style("font-size","5px")
    .attr("text-anchor", "middle")
    .attr("transform","translate(0, 36)")
    //.style("fill", "white")
    .transition()
    .duration(300)
    .style("font-size","12px")
 // .attr("font-family", "sans-serif")
 // .attr("font-size", "11px")
    .style("visibility", "hidden"); //hide under hover over the node 
    
    gnodes.append("text")
    .text(function(d) { 
        return ("Honeypot: " + d.honeypot); 
    })
    .attr("class","nodetext")
    .attr("dx", 0)
    .attr("dy", ".35em")
    .style("font-size","5px")
    .attr("text-anchor", "middle")
    .attr("transform","translate(0, 48)")
    //.style("fill", "white")
    .transition()
    .duration(300)
    .style("font-size","12px")
 // .attr("font-family", "sans-serif")
 // .attr("font-size", "11px")
    .style("visibility", "hidden"); //hide under hover over the node 
    
    gnodes.append("text")
    .text(function(d) { 
        return ("Intrusion detection: " + d.intrusion_detect); 
    })
    .attr("class","nodetext")
    .attr("dx", 0)
    .attr("dy", ".35em")
    .style("font-size","5px")
    .attr("text-anchor", "middle")
    .attr("transform","translate(0, 60)")
    //.style("fill", "white")
    .transition()
    .duration(300)
    .style("font-size","12px")
 // .attr("font-family", "sans-serif")
 // .attr("font-size", "11px")
    .style("visibility", "hidden"); //hide under hover over the node
    //console.log(labels);

    gnodes.append("text")
    .text(function(d) { 
        return ("Software up to date: " + d.software_uptodate); 
    })
    .attr("class","nodetext")
    .attr("dx", 0)
    .attr("dy", ".35em")
    .style("font-size","5px")
    .attr("text-anchor", "middle")
    .attr("transform","translate(0, 72)")
    //.style("fill", "white")
    .transition()
    .duration(300)
    .style("font-size","12px")
 // .attr("font-family", "sans-serif")
 // .attr("font-size", "11px")
    .style("visibility", "hidden"); //hide under hover over the node
    //console.log(labels);

    gnodes.append("text")
    .text(function(d) { 
        return ("Infected with: " + d.infected_with); 
    })
    .attr("class","nodetext")
    .attr("dx", 0)
    .attr("dy", ".35em")
    .style("font-size","5px")
    .attr("text-anchor", "middle")
    .attr("transform","translate(0, 84)")
    //.style("fill", "white")
    .transition()
    .duration(300)
    .style("font-size","12px")
 // .attr("font-family", "sans-serif")
 // .attr("font-size", "11px")
    .style("visibility", "hidden"); //hide under hover over the node
    //console.log(labels);


//Every time the simulation "ticks", this will be called
  force.on("tick", function() {
    edges.attr("x1", function(d) { return d.source.x; })
         .attr("y1", function(d) { return d.source.y; })
	     .attr("x2", function(d) { return d.target.x; })
	     .attr("y2", function(d) { return d.target.y; });

    gnodes.attr("transform", function(d) { 
        temp = 'translate(' + [d.x, d.y] + ')'
      return 'translate(' + [d.x, d.y] + ')';         
     })
  });
}
/*
function duplicate(dataset)
{
    var newNodes = [];
    var newEdges = [];
    var test = {};
    console.log("Current edges", dataset.edges[0]);
    test = $.extend({}, dataset.edges);
    console.log("Test", test);
    for (var i = 0; i < dataset.nodes.length; i++)
     {newNodes[i]= $.extend({}, dataset.nodes[i]);} 
    
    for (var i = 0; i < dataset.edges.length; i++)
    {newEdges[i] = $.extend({}, dataset.edges[i]);}
    console.log("Nodes", newNodes);
    console.log("Edges", newEdges);
    var clone = {
        nodes: newNodes,
        edges: newEdges
    }
    
    //clone = $.extend({}, dataset);
    console.log("duplicate()", clone);
    return clone;
}*/

function generate_custom()
{
    var type, graph_data, num_nodes;
    
    $(document).ready(function(){
    $("#divLevelCustom").empty();
	nodeTextBox = $(document.createElement('div'))
	     .attr("id", 'nodeTextBoxDiv');
 
	nodeTextBox.after().html('<label>Number of nodes' + ' : </label>' +
	      '<input type="text" name="textbox' + 
	      '" id="textbox' + '" value="" >');
 
	nodeTextBox.appendTo("#divLevelCustom");
    });
    
    topologySelectMenu = $("<select />");
      $("<option />", {value: -1, 
                       text: "Select network topology"})
                       .appendTo(topologySelectMenu);
      
      //create option for each node
      for(var val in topologies)
      {
       $("<option />", {value: val, 
                        text: topologies[val]})
                        .appendTo(topologySelectMenu);
      }
      topologySelectMenu.appendTo("#divLevelCustom");
      topologySelectMenu.on("change", function(e) {
          type = this.options[e.target.selectedIndex].text; 
          numNodes = parseInt($("#textbox").val());
          graph_data = generate_graph_data(numNodes, type);
          attackSelectMenu = $("<select />");
           $("<option />", {value: -1, 
                            text: "Select worm/attack method"})
                            .appendTo(attackSelectMenu);
      
           //create option for each node
           for(var val in attacks)
           {
             $("<option />", {value: val, 
                             text: attacks[val]})
                             .appendTo(attackSelectMenu);
           }
           attackSelectMenu.appendTo("#divLevelCustom");
           attackSelectMenu.on("change", function(f) {
           if(this.options[f.target.selectedIndex].text == "DDoS.Smurf") {
               smurf = true;
               //run normal simulation first
               //keep track of infected nodes
               //run backwards to remove initial spawned node
               //remove edge between spawn and hub to indicate incapacity
             //generate_dropdown(graph_data, "divLevelCustom")
               console.log("Smurf Graph data", graph_data);
               $("#commentary").fadeOut(function() {
                 $(this).text("Smurf DDoS attack running on " + type 
                              + " network with " + numNodes 
                              + " nodes").fadeIn(2000);
                 $(this).text("Smurf DDoS attack running on " + type 
                              + " network with " + numNodes 
                              + " nodes").fadeOut(2000);
                });
               generate_graph(graph_data);
               start_smurf_simulation(graph_data);
           }
           else if(this.options[f.target.selectedIndex].text 
                   == "Botnet.Storm") {
           botnetMinMenu = $("<select />");
           $("<option />", {value: -1, 
                            text: "Select minimum nodes required" 
                                   + " for node incapacitation"})
                            .appendTo(botnetMinMenu);
            for(var i = 1; i < numNodes; i++)
            {
             $("<option />", {value: i, 
                             text: i})
                             .appendTo(botnetMinMenu);
             }
             botnetMinMenu.appendTo("#divLevelCustom");
             botnetMinMenu.on("change", function(g) {
             botnetMin = parseInt(this.options[g.target.selectedIndex].text)
             $("#commentary").fadeOut(function() {
               $(this).text("Storm botnet running on " + type 
                            + " network with " + numNodes 
                            + " nodes" + " incapacitation minimum " 
                            + botnetMin.toString()).fadeIn(2000);
               $(this).text("Storm botnet running on " + type 
                            + " network with " + " incapacitation minimum " 
                            + botnetMin.toString()).fadeOut(2000);
              });
               generate_graph(graph_data);
                 start_storm_simulation(graph_data); });
           }
           else 
           {
             $("#commentary").fadeOut(function() {
               $(this).text(type + " Network generated with " 
                                 + numNodes + " nodes").fadeIn(2000);
               $(this).text(type + " Network generated with " 
                                 + numNodes + " nodes").fadeOut(2000);
            });
             generate_dropdown(graph_data, "divLevelCustom")
             generate_graph(graph_data);
           } 
         });
      });
}

function start_storm_simulation(dataset)
{
 
    spawn = spawnWorm("W32.STORM");
    gnodes.data()[spawn].infected_with = "W32.STORM";
    window.setTimeout(function() {
        $("#commentary").fadeOut(function() {
            console.log(gnodes.data()[spawn].name);
          $(this).text("Node: " + (spawn)
                       + " infected with W32.STORM!").fadeIn(2000);
          $(this).text("Node: " + (spawn)
                       + " infected with W32.STORM!").fadeOut(2000);
        });
    }, 2000);
    //botnetMin = 4;
    console.log(dataset);
    start(dataset, "W32.STORM");
}

function start_smurf_simulation(dataset)
{
  spawn = spawnWorm("W32.SLAMMER");
  smurfData = dataset;//duplicate(dataset);
  console.log("start_smurf(): smurfdata, ", smurfData);
  //infect a random node
  gnodes.data()[spawn].infected_with = "W32.SLAMMER";
  window.setTimeout(function() {
        $("#commentary").fadeOut(function() {
            console.log(gnodes.data()[spawn].name);
          $(this).text("Node: " + (spawn - 1)
                       + " infected with W32.SLAMMER!").fadeIn(2000);
          $(this).text("Node: " + (spawn - 1)
                       + " infected with W32.SLAMMER!").fadeOut(2000);
        });
    }, 2000);
  console.log("start_smurf(): spawn node ", gnodes.data()[spawn]);
  start(smurfData, "W32.SLAMMER"); 
}

function updateSmurf()
{
  gnodes.data()[0].infected_with = "none"; //reset so can propgate backwards
    for(var i = 0; i < gnodes.data().length; i++) {
      if(gnodes.data()[i].infected_with == "W32.SLAMMER" && i != spawn)
        infections.push({x: gnodes.data()[0].x,
                         y: gnodes.data()[0].y,
                         infectedByx: 
                           gnodes.data()[i].x,
                         infectedByy: 
                           gnodes.data()[i].y,
                         });
    }
    getWormCoords();
    createWorm();
    console.log("updateSmurf(): xyCoords1", xyCoords);
    
    moveWorm();
    settleLayout();
    window.setTimeout(function() {
        d3.selectAll("svg").remove();
        d3.selectAll(".worm").remove();
        generate_graph(smurfData);
        //settleLayout();
     }, 3500);
    settleLayout();
    window.setTimeout(function() {
     xyCoords = []
     xyCoords.push({id: 0, targetX: gnodes.data()[spawn].x
                     , targetY: gnodes.data()[spawn].y
                     , sourceX: gnodes.data()[0].x
                     , sourceY: gnodes.data()[0].y});
    createWorm();
    console.log("updateSmurf(): xyCoords2", xyCoords);
    
    moveWorm();
    }, 7000);
    
    window.setTimeout(function() {
        d3.selectAll("svg").remove();
        d3.selectAll(".worm").remove();
        stopSimulation = true;
        console.log(smurfData);
       // find the edge corresponding to the node 
      //for(var i = 0; i < smurfData.edges.length; i++)
           //    console.log(smurfData.edges);
            /*if(smurfData.edges[i].source == gnodes.data()[spawn].index - 1) {
                //console.log("val", val.source);
        smurfData.edges
                 .splice(val.index, 1);
            }*/
        gnodes.data()[spawn].infected_with 
               = "W32.SLAMMER";
        gnodes.data()[spawn].status = "incapacitated";
        generate_graph(smurfData);
        return;
     }, 10500);
}

function dfs_auxillary(nodes, u, n)
{
    visited[u] = "y";

    for(var i = 0; i < nodes[u].adjacent_to.length; i++)
    {
        if(visited[nodes[u].adjacent_to[i]] == "n") {
            n++;
            dfs_auxillary(nodes, nodes[u].adjacent_to[i], n);
         }
        else
        {
           if(n > counter) 
             counter = n;
           n = 0;
        }
    }
}


function dfs_max_reachability()
{
    counter = 0;
    max = 0;

    
    for(var j = 0; j < gnodes.data().length; j++) {
     for(var i = 0; i < gnodes.data().length; i++)
        visited[i] = "n";
      dfs_auxillary(gnodes.data(), j, 0);
      if(counter > max)
          max = counter;
      counter = 0;
    }
    
    console.log(max);
}

function generate_graph_data(num_nodes, type)
{

    var i, j, dataset = {
        nodes :[],
        edges :[]
    }

    if(type == "Line")
    {
      for(i = 0; i < num_nodes; i++)
      {
          dataset.nodes.push({name: "node " + i, system_type: "W32"
                             , social_eng: "false"
                             , intrusion_detect: " false"
                             , honeypot: " false"
                             , software_uptodate: " false"
                             , infected_with: "none"
                             , adjacent_to: []});
         if(i == 0)
           dataset.nodes[i].adjacent_to.push(i+1);
         else if(i == num_nodes - 1)
           dataset.nodes[i].adjacent_to.push(i-1);
         else
           dataset.nodes[i].adjacent_to.push(i-1, i+1);
      }
        
      for(j = 0; j <  num_nodes - 1; j++)
        dataset.edges.push({ source: j, target: j + 1 });
    }
    else if(type == "Star")
    {
      dataset.nodes.push({name: "Central Hub", system_type: "NA"
                             , social_eng: "false"
                             , intrusion_detect: " false"
                             , honeypot: " false"
                             , software_uptodate: " false"
                             , status: "active"
                             , infected_with: "none"
                             , adjacent_to: []});
       
      for(i = 0 ; i < num_nodes; i++)
      {
          dataset.nodes.push({name: "node " + i, system_type: "W32"
                             , social_eng: "false"
                             , intrusion_detect: " false"
                             , honeypot: " false"
                             , software_uptodate: " false"
                             , status: "active"
                             , infected_with: "none"
                             , adjacent_to: []});
      }
      for(i = 1; i < num_nodes + 1; i++)
          dataset.nodes[0].adjacent_to.push(i);
      for(j = 1; j <  num_nodes + 1; j++)
      {
        dataset.nodes[j].adjacent_to.push(0);
        dataset.edges.push({ source: j, target: 0 });
      }
        console.log("gen_graph_data(): dataset ", dataset);
    }
    else if(type == "Mesh")
    {
      var randLength;
      var randNode;
        
      for(i = 0 ; i < num_nodes; i++)
      {
          dataset.nodes.push({name: "node " + i, system_type: "W32"
                             , social_eng: "false"
                             , intrusion_detect: " false"
                             , honeypot: " false"
                             , software_uptodate: " false"
                             , status: "active"
                             , infected_with: "none"
                             , adjacent_to: []});
      }
      for(j = 0; j < num_nodes; j++)
      {
          randLength = Math.floor((Math.random() 
                                      * (num_nodes/2)) + 1); //cant be 0
         // console.log("Mesh:", randLength);
          for(var k = 0; k < randLength; k++)
          {
              randNode = Math.floor((Math.random() 
                                      * (num_nodes)));
              console.log("Node:", randNode);
              dataset.nodes[j].adjacent_to.push(randNode);
              dataset.edges.push({ source: j, target: randNode });
          }
          
      }
        console.log(dataset);
    }
    else if(type == "Ring")
    {
      for(i = 0; i < num_nodes; i++)
      {
          dataset.nodes.push({name: "node " + i, system_type: "W32"
                             , social_eng: "false"
                             , intrusion_detect: " false"
                             , honeypot: " false"
                             , software_uptodate: " false"
                             , status: "active"
                             , infected_with: "none"
                             , adjacent_to: []});
         if(i == 0)
           dataset.nodes[i].adjacent_to.push(i+1, num_nodes - 1);
         else if(i == num_nodes - 1)
           dataset.nodes[i].adjacent_to.push(i-1, 0);
         else
           dataset.nodes[i].adjacent_to.push(i-1, i+1);
      }
        
      for(j = 0; j <  num_nodes - 1; j++)
        dataset.edges.push({ source: j, target: j + 1 });
      dataset.edges.push({ source: j, target: 0 });
    }
    else if(type == "Complete")
    {
      for(i = 0; i < num_nodes; i++)
      {
          dataset.nodes.push({name: "node " + i, system_type: "W32"
                             , social_eng: "false"
                             , intrusion_detect: " false"
                             , honeypot: " false"
                             , software_uptodate: " false"
                             , status: "active"
                             , infected_with: "none"
                             , adjacent_to: []});    
      }
      //n(n-1)/2 nodes in complete graph
      for(j = 0; j < num_nodes; j++)
      {
          for(i = 0; i < num_nodes; i++)
          {
            if(i != j)
            {
                dataset.nodes[j].adjacent_to.push(i);
                dataset.edges.push({source: j, target: i});
            }
          }
      }
    }
    
    return dataset;
}

function generate_dropdown(dataset, div_location)
{
  // dataset = duplicate(dataset);
  //if the user has not set any levels
 // if(!selected) {
    $(document).ready(function() {
        
      wormSelectMenu = $("<select />");
      $("<option />", {value: -1, 
                       text: "Select worm"})
                       .appendTo(wormSelectMenu);
      
      //create option for each node
      for(var val in worms)
      {
       $("<option />", {value: val, 
                        text: worms[val].name})
                        .appendTo(wormSelectMenu);
      }
      wormSelectMenu.appendTo("#" + div_location);
      wormSelectMenu.on("change", function(e) {
      worm = this.options[e.target.selectedIndex].text;
          //create release button
      $("wormbtn").hide();
      wormbtn = $("<button/>", {text: "Release Worm", 
                           id: "wormbtn",
                           click: function () {          
                            spawn = spawnWorm(worm);
                            //infect a random node
                            gnodes.data()[spawn].infected_with = worm;
                            window.setTimeout(function() {
                              $("#commentary").fadeOut(function() {
                                $(this).text((gnodes.data()[spawn].name) 
                                   .concat(" infected with ") + worm).fadeIn(2000);
                                $(this).text((gnodes.data()[spawn].name) 
                                   .concat(" infected with ") + worm).fadeOut(2000);
                              });
                            }, 2000);
                            start(dataset, worm);
                            $("#wormbtn").hide();
                            $("#" + div_location).empty();
                        }
                 }).appendTo("#" + div_location);
       })
       $("<br />").appendTo("#" + div_location);
      //create dropdowns for networks
      networkSelectMenu = $("<select />");
      $("<option />", {value: -1, 
                       text: "Please Select Network"})
                       .appendTo(networkSelectMenu);
      
      //create option for each node
      for(var val in dataset.nodes)
      {
       if(dataset.nodes[val].name != "Central Hub")
         $("<option />", {value: val, 
                          text: dataset.nodes[val].name})
                          .appendTo(networkSelectMenu);
      }
      networkSelectMenu.appendTo("#" + div_location);
        
      //generate the next dropdown
      networkSelectMenu.on('change', function(e) {
       // console.log(this.options[e.target.selectedIndex].text);
        
        socialEngSelectMenu = $("<select />");
        $("<option />", {value: -1, 
                         text: "Enable Social Engineering training"})
                         .appendTo(socialEngSelectMenu);
        for(var val in bool_params)  
        {
        $("<option />", {value: val, 
                         text: bool_params[val]})
                         .appendTo(socialEngSelectMenu);
        }

        socialEngSelectMenu.appendTo("#" + div_location);
       // console.log(socialEngSelectMenu.val());
        socialEngSelectMenu.on("change", function(f) {
            //if not the "Please select" option which is -1
            if(socialEngSelectMenu.val() >= 0) {
              dataset.nodes[e.target.selectedIndex - 1].social_eng
                           = bool_params[f.target.selectedIndex - 1];
                
              //create honeypot select menu
              honeypotSelectMenu = $("<select />");
              $("<option />", {value: -1, 
                                text: "Enable honeypot"})
                                .appendTo(honeypotSelectMenu);
              for(var val in bool_params)  
              {
                $("<option />", {value: val, 
                                  text: bool_params[val]})
                                  .appendTo(honeypotSelectMenu);
              }
              honeypotSelectMenu.appendTo("#" + div_location);
              honeypotSelectMenu.on("change", function(g) {
                    if(honeypotSelectMenu.val() >= 0) {
                      dataset.nodes[e.target.selectedIndex - 1].honeypot
                             = bool_params[g.target.selectedIndex - 1];
                          
                               
                    //create honeypot select menu
                     intrusionDetectMenu = $("<select />");
                     $("<option />", {value: -1, 
                                       text: "Enable intrusion detection"})
                                       .appendTo(intrusionDetectMenu);  


                     for(var val in bool_params)  
                     {
                      $("<option />", {value: val, 
                                       text: bool_params[val]})
                                       .appendTo(intrusionDetectMenu);
                     }         
                     intrusionDetectMenu.appendTo("#" + div_location);
                     intrusionDetectMenu.on("change", function(h) {
                       if(intrusionDetectMenu.val() >= 0) {
                        dataset.nodes[e.target.selectedIndex - 1]
                               .intrusion_detect
                             = bool_params[h.target.selectedIndex - 1];

                     softwareMenu = $("<select />");
                     $("<option />", {value: -1, 
                                       text: "Software up to date?"})
                                       .appendTo(softwareMenu);  
                     for(var val in bool_params)  
                     {
                      $("<option />", {value: val, 
                                       text: bool_params[val]})
                                       .appendTo(softwareMenu);
                     }  
                     softwareMenu.appendTo("#" + div_location);
                     softwareMenu.on("change", function(i) {
                     if(softwareMenu.val() >= 0) {
                        dataset.nodes[e.target.selectedIndex - 1]
                         .software_uptodate
                             = bool_params[i.target.selectedIndex - 1]; 

                        intrusionDetectMenu.remove();
                        softwareMenu.remove();
                        socialEngSelectMenu.remove();
                        honeypotSelectMenu.remove();
                        //refresh graph
                        d3.selectAll("svg").remove();
                        generate_graph(dataset); 
                     } });
                    }
              })
          }           
              });
               //refresh the graph
               d3.selectAll("svg").remove();
               generate_graph(dataset);
        }
      })
    })
    })
}

function start(dataset, worm) 
{
  var i = 0;
  //i++ < maximum number of steps req to reach any node from target using    shortest path
  dfs_max_reachability();
  while(i++ < dataset.nodes.length) 
  {
     //console.log(stopSimulation);             
     window.setTimeout(function() {
       if(stopSimulation) {
        d3.selectAll("svg").remove();
        d3.selectAll(".worm").remove();
        generate_graph(dataset);
         return;
       }
       runSimulation(dataset, worm);
     }, 500 + i * 3500);
      
     window.setTimeout(function() {
        d3.selectAll("svg").remove();
        d3.selectAll(".worm").remove();
        generate_graph(dataset);
       if(stopSimulation) {
         return;
       }
     }, 4000 + i * 3500);
  }                      
}
    
var timer = null;
function onCompletion(interval) {

    function retryIfRunning() {
        if (force.alpha() != 0) {
            console.log("HELLO");
            setTimeout(checkAndRetry, interval); 
            console.log(force.alpha());}
        else {
            console.log("WHY U NO GO HERE");
            updateInfections();
        }
    }

    retryIfRunning();
}

function checkAndRetry()
{
}

//infect a random node
function spawnWorm(worm)
{
    var candidateNodes = [];
    console.log(worm);
    for(var i = 0; i < gnodes.data().length; i++)
    {
        if(can_infect(gnodes.data()[i], worm) 
           && gnodes.data()[i].name != "Central Hub") 
              candidateNodes.push(i);
    }
    
    //console.log(candidateNodes);
   // console.log(candidateNodes[Math.floor((Math.random() 
                     //                 * (candidateNodes.length)))]);
    return candidateNodes[Math.floor((Math.random() 
                                      * (candidateNodes.length)))];
}


function runSimulation(dataset, worm)
{
   //needs to update once graph has settled
   //onCompletion(1000);
   
   var i = 0;
   settleLayout();
   updateInfections(worm);
   getWormCoords();
   //console.log(xyCoords);
    if(smurf && xyCoords.length == 0){
        updateSmurf();
        return;
    }
    //else if(xyCoords.length == 0) {
       //console.log(gnodes.data()[0]);
     //  window.alert("Propogation halted!");
  //  }
   createWorm();
   moveWorm(dataset);

}

function settleLayout()
{
  var safety = 0;
  while(force.alpha() != 0) 
  {
     force.tick();
     if(safety++ > 500) 
        break;
  }
}

//create worms from the infected nodes
function createWorm() 
{

  var worm = svg.selectAll(".worm")
     .data(xyCoords)
     .enter()
     .append("circle")
     .attr("class", "worm")
     .attr("cx", function(d, i) {
        // console.log(d);
         return d.sourceX })
     .attr("cy", function(d) { 
         return d.sourceY})
     .attr("r", 4)
     .style("fill", "black")
}

//move worm from source to target
function moveWorm(dataset) 
{
 // console.log(xyCoords);
  stageEnded = false;
  d3.selectAll(".worm")
    .transition()
    .duration(4000)
    .attr("cx", function(d) {
        return d.targetX } )
    .attr("cy", function(d) { 
        return d.targetY } )
    .each("end", function(d) { //listen for end of event
       // gnodes.data()[d.id].infected_with = "W32.BORM";
        //refresh graph with new values
        //d3.selectAll("svg").remove();
       // generate_graph(dataset); 
        stageEnded = true;});
   $('.worm').fadeOut(5000); //fade out the worm
   
 }

//spawn worm
//update infections
//move worm
//remove svg's
// (repeat)

//get source (infected nodes) and target (nodes to be infected) coords
//funciton skipping ahead and infecting before worm transmitted//
function updateInfections(worm)
{
    var adjLength, node;
    honeypots = [];
    stopSimulation = true;
    infections = []; //nodes to infect
   
   if(worm != "W32.STORM")
       newMarkedInfections = []; //mark the newly infected nodes to avoid transmitting worms from newly infected nodes within loop
    
    //find all nodes reachable from infected ones
    //update the infection array with these node params
    for(var i = 0; i < gnodes.data().length; i++)
    {
        if(gnodes.data()[i].infected_with != "none"
            && gnodes.data()[i].honeypot == " false") 
        {
            //get indexes of already infected nodes
            newMarkedInfections.push(i);
            //console.log(newMarkedInfections);
        }
    }
    
    //for each node in graph, check if in adjacency list of
    //any of the infected nodes
    //if so then mark it as infected and get worm coords
    
    //for each infected node
    //check if nodes adjacent are not infected
    //infect them if so
    
    if(worm == "W32.STORM" && newMarkedInfections.length > botnetMin) //does not follow normal propogation 
    {
        for(var j = 0; j < newMarkedInfections.length; j++)
        {
            //for all of the infected nodes, find a node adjacent to one
            //if can infect it, then infect it from all the other nodes
            //incapacitate it but also infect it
            //continue until all nodes incapacitated or infected
            //console.log("Botnet loop",newMarkedInfections);
            adjLength = gnodes.data()[newMarkedInfections[j]]
              .adjacent_to.length;
            for(var i = 0; i < adjLength; i++)
            {
            node = gnodes.data()[newMarkedInfections[j]]
              .adjacent_to[i];
                  if(gnodes.data()[node].infected_with == "none" 
                     && can_infect(gnodes.data()[node], worm)) {
                    stopSimulation = false;
                    gnodes.data()[node].infected_with = worm;
                    gnodes.data()[node].status = "incapacitated";
                    for(var k = 0; k < newMarkedInfections.length; k++)
                    {
                      //console.log(infections);
                      if(gnodes.data()[newMarkedInfections[k]].status 
                         == "active")
                        infections.push({x: gnodes.data()[node].x,
                                         y: gnodes.data()[node].y,
                                         infectedByx: 
                                         gnodes.data()[newMarkedInfections[k]].x,
                                         infectedByy: 
                                         gnodes.data()[newMarkedInfections[k]].y,
                                        });
                    }
                    console.log(infections);
                    return;
                  }
                    
                  }
             
        }
    }
    else {
    for(var j = 0; j < newMarkedInfections.length; j++)
    {
        //check for honeypots, ******not updating graph????*****
        //console.log(gnodes.data()[newMarkedInfections[j]]);
        if((honeypots = honeypot_adjacent(gnodes
                        .data()[newMarkedInfections[j]])).length > 0) {
            $("#commentary").fadeOut(function() {
              $(this).text("Honeypot adjacent!").fadeIn(2000);
              $(this).text("Honeypot adjacent!").fadeOut(2000);
            });
            for(var i = 0; i < honeypots.length; i++) {
                stopSimulation = false;
                gnodes.data()[honeypots[i]].infected_with = worm;
                console.log(gnodes.data()[honeypots[i]].infected_with);
                infections.push({x: gnodes.data()[honeypots[i]].x,
                                 y: gnodes.data()[honeypots[i]].y,
                                 infectedByx: 
                                     gnodes.data()[newMarkedInfections[j]].x,
                                 infectedByy: 
                                     gnodes.data()[newMarkedInfections[j]].y,
                                 });
            }
            honeypots = [];
        }
        else {
        gnodes.data()[newMarkedInfections[j]]
              .adjacent_to.forEach(function(element, index) {
                  if(gnodes.data()[element].infected_with == "none" 
                     && can_infect(gnodes.data()[element], worm)) {
                    stopSimulation = false;
                    gnodes.data()[element].infected_with = worm;
                    infections.push({x: gnodes.data()[element].x,
                                     y: gnodes.data()[element].y,
                                     infectedByx: 
                                     gnodes.data()[newMarkedInfections[j]].x,
                                     infectedByy: 
                                     gnodes.data()[newMarkedInfections[j]].y,
                                    });
                  }
              });
    }
    }
    }
}
                                   
                                 
//get coords for where the worm needs to transmit between
//infections needs to store node id's of new infections
function getWormCoords()
{
    xyCoords = [];
    for(var i = 0; i < infections.length; i++)
    {
        xyCoords.push({id: i, targetX: infections[i].x
                     , targetY: infections[i].y
                     , sourceX: infections[i].infectedByx
                     , sourceY: infections[i].infectedByy});
    }
}

function can_infect(node, worm)
{
    //console.log(worm);
    
    if(worm == "W32.BLASTER")
    {
        if(node.software_uptodate == " true")
          return false;
        else
          return true;
    }
    else if(worm == "W32.BORM")
    {
        if(node.intrusion_detect == " true")
            return false;
        else
          return true;
    }
    else if(worm == "W32.ILOVEYOU")
    {
        if(node.social_eng == " true")
            return false;
        else
            return true;
    }
    else
      return true;
}

function honeypot_adjacent(node)
{
    var adjacent_node;
    var honeypots = [];
    
    for(var i = 0; i < node.adjacent_to.length; i++)
    {
        adjacent_node = node.adjacent_to[i];
        if(gnodes.data()[adjacent_node].honeypot == " true")
          honeypots.push(adjacent_node);
    }
    
   return honeypots;
}


//info and legend dialog boxes
$(document).ready(function () {
    $("#Info").dialog({
        autoOpen: false,
        dialogClass: 'dialogStyle',
        resizable: false,
        height: 140,
        modal: false,
        buttons: {
            Close: function () {
                $(this).dialog("close");
                $("#Info").remove();
            }
        }
    });
    $(".Info").click(function () {
        $("#Info").dialog("open");
    });
    
    $("#Legend").dialog({
        autoOpen: false,
        dialogClass: 'dialogStyle',
        resizable: false,
        height: 240,
        buttons: {
            Close: function () {
                $(this).dialog("close");
                $("#Legend").remove();
            }
        }
    });
    $(".Legend").click(function () {
        $("#Legend").dialog("open");
    });
});

      </script>
    </body>
</html>

